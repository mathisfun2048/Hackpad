#include "oled.h"
#include "config.h"
#include "pico/stdlib.h"
#include <string.h>

// 5x7 font (ASCII 32-126)
static const uint8_t font5x7[][5] = {
    {0x00, 0x00, 0x00, 0x00, 0x00}, // Space
    {0x00, 0x00, 0x5F, 0x00, 0x00}, // !
    {0x00, 0x07, 0x00, 0x07, 0x00}, // "
    {0x14, 0x7F, 0x14, 0x7F, 0x14}, // #
    {0x24, 0x2A, 0x7F, 0x2A, 0x12}, // $
    {0x23, 0x13, 0x08, 0x64, 0x62}, // %
    {0x36, 0x49, 0x55, 0x22, 0x50}, // &
    {0x00, 0x05, 0x03, 0x00, 0x00}, // '
    {0x00, 0x1C, 0x22, 0x41, 0x00}, // (
    {0x00, 0x41, 0x22, 0x1C, 0x00}, // )
    {0x14, 0x08, 0x3E, 0x08, 0x14}, // *
    {0x08, 0x08, 0x3E, 0x08, 0x08}, // +
    {0x00, 0x50, 0x30, 0x00, 0x00}, // ,
    {0x08, 0x08, 0x08, 0x08, 0x08}, // -
    {0x00, 0x60, 0x60, 0x00, 0x00}, // .
    {0x20, 0x10, 0x08, 0x04, 0x02}, // /
    {0x3E, 0x51, 0x49, 0x45, 0x3E}, // 0
    {0x00, 0x42, 0x7F, 0x40, 0x00}, // 1
    {0x42, 0x61, 0x51, 0x49, 0x46}, // 2
    {0x21, 0x41, 0x45, 0x4B, 0x31}, // 3
    {0x18, 0x14, 0x12, 0x7F, 0x10}, // 4
    {0x27, 0x45, 0x45, 0x45, 0x39}, // 5
    {0x3C, 0x4A, 0x49, 0x49, 0x30}, // 6
    {0x01, 0x71, 0x09, 0x05, 0x03}, // 7
    {0x36, 0x49, 0x49, 0x49, 0x36}, // 8
    {0x06, 0x49, 0x49, 0x29, 0x1E}, // 9
    {0x00, 0x36, 0x36, 0x00, 0x00}, // :
    {0x00, 0x56, 0x36, 0x00, 0x00}, // ;
    {0x08, 0x14, 0x22, 0x41, 0x00}, // <
    {0x14, 0x14, 0x14, 0x14, 0x14}, // =
    {0x00, 0x41, 0x22, 0x14, 0x08}, // >
    {0x02, 0x01, 0x51, 0x09, 0x06}, // ?
    {0x32, 0x49, 0x79, 0x41, 0x3E}, // @
    {0x7E, 0x11, 0x11, 0x11, 0x7E}, // A
    {0x7F, 0x49, 0x49, 0x49, 0x36}, // B
    {0x3E, 0x41, 0x41, 0x41, 0x22}, // C
    {0x7F, 0x41, 0x41, 0x22, 0x1C}, // D
    {0x7F, 0x49, 0x49, 0x49, 0x41}, // E
    {0x7F, 0x09, 0x09, 0x09, 0x01}, // F
    {0x3E, 0x41, 0x49, 0x49, 0x7A}, // G
    {0x7F, 0x08, 0x08, 0x08, 0x7F}, // H
    {0x00, 0x41, 0x7F, 0x41, 0x00}, // I
    {0x20, 0x40, 0x41, 0x3F, 0x01}, // J
    {0x7F, 0x08, 0x14, 0x22, 0x41}, // K
    {0x7F, 0x40, 0x40, 0x40, 0x40}, // L
    {0x7F, 0x02, 0x0C, 0x02, 0x7F}, // M
    {0x7F, 0x04, 0x08, 0x10, 0x7F}, // N
    {0x3E, 0x41, 0x41, 0x41, 0x3E}, // O
    {0x7F, 0x09, 0x09, 0x09, 0x06}, // P
    {0x3E, 0x41, 0x51, 0x21, 0x5E}, // Q
    {0x7F, 0x09, 0x19, 0x29, 0x46}, // R
    {0x46, 0x49, 0x49, 0x49, 0x31}, // S
    {0x01, 0x01, 0x7F, 0x01, 0x01}, // T
    {0x3F, 0x40, 0x40, 0x40, 0x3F}, // U
    {0x1F, 0x20, 0x40, 0x20, 0x1F}, // V
    {0x3F, 0x40, 0x38, 0x40, 0x3F}, // W
    {0x63, 0x14, 0x08, 0x14, 0x63}, // X
    {0x07, 0x08, 0x70, 0x08, 0x07}, // Y
    {0x61, 0x51, 0x49, 0x45, 0x43}, // Z
    {0x00, 0x7F, 0x41, 0x41, 0x00}, // [
    {0x02, 0x04, 0x08, 0x10, 0x20}, // backslash
    {0x00, 0x41, 0x41, 0x7F, 0x00}, // ]
    {0x04, 0x02, 0x01, 0x02, 0x04}, // ^
    {0x40, 0x40, 0x40, 0x40, 0x40}, // _
};

static uint8_t display_buffer[OLED_HEIGHT / 8][OLED_WIDTH];

// Software I2C functions
static void i2c_start(void) {
    gpio_set_dir(OLED_SDA_PIN, GPIO_OUT);
    gpio_put(OLED_SDA_PIN, 1);
    gpio_put(OLED_SCL_PIN, 1);
    sleep_us(1);
    gpio_put(OLED_SDA_PIN, 0);
    sleep_us(1);
    gpio_put(OLED_SCL_PIN, 0);
    sleep_us(1);
}

static void i2c_stop(void) {
    gpio_set_dir(OLED_SDA_PIN, GPIO_OUT);
    gpio_put(OLED_SDA_PIN, 0);
    gpio_put(OLED_SCL_PIN, 1);
    sleep_us(1);
    gpio_put(OLED_SDA_PIN, 1);
    sleep_us(1);
}

static bool i2c_write_byte(uint8_t byte) {
    gpio_set_dir(OLED_SDA_PIN, GPIO_OUT);
    for (int i = 7; i >= 0; i--) {
        gpio_put(OLED_SDA_PIN, (byte >> i) & 1);
        sleep_us(1);
        gpio_put(OLED_SCL_PIN, 1);
        sleep_us(1);
        gpio_put(OLED_SCL_PIN, 0);
        sleep_us(1);
    }
    
    // Read ACK
    gpio_set_dir(OLED_SDA_PIN, GPIO_IN);
    gpio_put(OLED_SCL_PIN, 1);
    sleep_us(1);
    bool ack = !gpio_get(OLED_SDA_PIN);
    gpio_put(OLED_SCL_PIN, 0);
    sleep_us(1);
    
    return ack;
}

static void oled_command(uint8_t cmd) {
    i2c_start();
    i2c_write_byte(OLED_ADDRESS << 1);
    i2c_write_byte(0x00);  // Command mode
    i2c_write_byte(cmd);
    i2c_stop();
}

static void oled_data(uint8_t data) {
    i2c_start();
    i2c_write_byte(OLED_ADDRESS << 1);
    i2c_write_byte(0x40);  // Data mode
    i2c_write_byte(data);
    i2c_stop();
}

bool oled_init(void) {
    // Initialize I2C pins
    gpio_init(OLED_SCL_PIN);
    gpio_init(OLED_SDA_PIN);
    gpio_set_dir(OLED_SCL_PIN, GPIO_OUT);
    gpio_set_dir(OLED_SDA_PIN, GPIO_OUT);
    gpio_put(OLED_SCL_PIN, 1);
    gpio_put(OLED_SDA_PIN, 1);
    
    sleep_ms(100);
    
    // SSD1306 initialization sequence
    oled_command(0xAE);  // Display off
    oled_command(0xD5);  // Set display clock
    oled_command(0x80);
    oled_command(0xA8);  // Set multiplex ratio
    oled_command(0x1F);  // 32 rows
    oled_command(0xD3);  // Set display offset
    oled_command(0x00);
    oled_command(0x40);  // Set start line
    oled_command(0x8D);  // Charge pump
    oled_command(0x14);
    oled_command(0x20);  // Memory mode
    oled_command(0x00);  // Horizontal
    oled_command(0xA1);  // Segment remap
    oled_command(0xC8);  // COM scan direction
    oled_command(0xDA);  // COM pins config
    oled_command(0x02);
    oled_command(0x81);  // Contrast
    oled_command(0x8F);
    oled_command(0xD9);  // Pre-charge period
    oled_command(0xF1);
    oled_command(0xDB);  // VCOMH deselect
    oled_command(0x40);
    oled_command(0xA4);  // Display all on resume
    oled_command(0xA6);  // Normal display
    oled_command(0xAF);  // Display on
    
    oled_clear();
    return true;
}

void oled_clear(void) {
    memset(display_buffer, 0, sizeof(display_buffer));
}

void oled_text(uint8_t x, uint8_t y, const char* str) {
    if (y >= 4) return;
    
    while (*str && x < OLED_WIDTH - 5) {
        uint8_t c = *str;
        if (c >= 32 && c <= 95) {
            for (int i = 0; i < 5; i++) {
                display_buffer[y][x + i] = font5x7[c - 32][i];
            }
            x += 6;
        }
        str++;
    }
}

void oled_update(void) {
    for (uint8_t page = 0; page < 4; page++) {
        oled_command(0xB0 + page);  // Set page
        oled_command(0x00);  // Set column low nibble
        oled_command(0x10);  // Set column high nibble
        
        for (uint8_t col = 0; col < OLED_WIDTH; col++) {
            oled_data(display_buffer[page][col]);
        }
    }
}

void oled_draw_grid(const char* keys[9], const char* title) {
    oled_clear();
    
    // Draw title
    oled_text(0, 0, title);
    
    // Draw 3x3 grid (compact layout for 128x32)
    // Each cell is about 42x10 pixels
    const uint8_t cell_w = 42;
    const uint8_t cell_h = 2;  // pages (16 pixels)
    
    for (int i = 0; i < 9; i++) {
        uint8_t row = i / 3;
        uint8_t col = i % 3;
        uint8_t x = col * cell_w + 2;
        uint8_t y = row + 1;  // Start at page 1 (below title)
        
        oled_text(x, y, keys[i]);
    }
    
    oled_update();
}
